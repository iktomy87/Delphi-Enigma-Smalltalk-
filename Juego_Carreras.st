ImageMorph subclass: #Enemigo_Carrera	instanceVariableNames: 'velocidad'	classVariableNames: ''	poolDictionaries: ''	category: 'Juego_Carreras'!!Enemigo_Carrera methodsFor: 'control' stamp: 'AlejandroTorres 11/18/2024 01:55'!detectarColision: auto2    | bounds_self bounds_auto2 left_self right_self top_self bottom_self       left_auto2 right_auto2 top_auto2 bottom_auto2 |    bounds_self := self bounds.    bounds_auto2 := auto2 bounds.    "Restamos 20 p‚àö‚â†xeles en X e Y a ambos autos"    "Para self"    left_self := bounds_self left + 20.    "Mueve el borde izquierdo 20 p‚àö‚â†xeles a la derecha"    right_self := bounds_self right - 20.  "Mueve el borde derecho 20 p‚àö‚â†xeles a la izquierda"    top_self := bounds_self top + 20.      "Mueve el borde superior 20 p‚àö‚â†xeles hacia abajo"    bottom_self := bounds_self bottom - 20. "Mueve el borde inferior 20 p‚àö‚â†xeles hacia arriba"    "Para auto2"    left_auto2 := bounds_auto2 left + 20.    "Mueve el borde izquierdo 20 p‚àö‚â†xeles a la derecha"    right_auto2 := bounds_auto2 right - 20.  "Mueve el borde derecho 20 p‚àö‚â†xeles a la izquierda"    top_auto2 := bounds_auto2 top + 20.      "Mueve el borde superior 20 p‚àö‚â†xeles hacia abajo"    bottom_auto2 := bounds_auto2 bottom - 20. "Mueve el borde inferior 20 p‚àö‚â†xeles hacia arriba"    "Verificar si hay colisi‚àö‚â•n, usando los l‚àö‚â†mites ajustados"    ((right_self >= left_auto2 and: [left_self <= right_auto2])        and: [bottom_self >= top_auto2 and: [top_self <= bottom_auto2]])         ifTrue: [            "Transcript show: 'Choc‚àö‚â•'; cr."            ^false.         ] ifFalse: [            "Transcript show: 'No hay colisi‚àö‚â•n'; cr."            ^true.         ].! !!Enemigo_Carrera methodsFor: 'initialization' stamp: 'AlejandroTorres 11/18/2024 02:27'!initialize super initialize. self image: (Form fromFileNamed: 'carreraEnemigo.png'). self position: 215@50. "Coordenadas de inico del enemigo"velocidad:= 15. 	 ! !!Enemigo_Carrera methodsFor: 'action' stamp: 'Tomas 11/21/2024 03:27'!moverEnemigo: aVector and: direccion[  	direccion caseOf: {        ['izq'] -> ["self bounds: ((self position) extent: 10 @ 10)."			self image: (Form fromFileNamed: 'Jugador-izq-120@100.png').			].          ['der'] -> ["self bounds: ((self position) extent: 10 @ 10)."			self image: (Form fromFileNamed: 'Jugador-der-120@100.png').			].          ['arriba'] -> ["self bounds: ((self position) extent: 70@ 100)."			self image: (Form fromFileNamed: 'Jugador-100@100.png').			].           ['abajo'] -> ["self bounds: ((self position) extent: 70 @ 100)."			self image: (Form fromFileNamed: 'Jugador-100@100.png').			].       } otherwise: [].	"Transcript show: self position."	self position: self position + aVector.] fork.! !!Enemigo_Carrera methodsFor: 'accessing' stamp: 'AlejandroTorres 11/14/2024 12:27'!velocidad: anObject	velocidad := anObject! !!Enemigo_Carrera methodsFor: 'accessing' stamp: 'AlejandroTorres 11/14/2024 12:27'!velocidad	^ velocidad! !Morph subclass: #Juego_Carreras	instanceVariableNames: 'corriendo jugador textoScore gameOver gameEndCallback score'	classVariableNames: ''	poolDictionaries: ''	category: 'Juego_Carreras'!!Juego_Carreras methodsFor: 'initialization' stamp: 'AlejandroTorres 11/18/2024 02:04'!crearFondo|fondo|	fondo:= ImageMorph new.   fondo image: (Form fromFileNamed: 'FondoCarreras.png').    "Ajusta el tama‚àö¬±o del Morph al tama‚àö¬±o deseado"    fondo extent: 640 @ 640.  "Tama‚àö¬±o del Morph"        "Coloca el Morph en la ventana"    fondo bounds: (0 @ 0 extent: 640 @ 640). "Posici‚àö‚â•n y tama‚àö¬±o"        "Ajusta el tama‚àö¬±o del men‚àö‚à´"    self extent: 640 @ 640.	self addMorph: fondo.! !!Juego_Carreras methodsFor: 'initialization' stamp: 'Tomy 11/21/2024 09:47'!initialize	super initialize.  	self color: Color black.  "Se pone negro el fondo por un datalle en el sprite del fondo" 	self bounds: (0@0 extent: 640@640). "Establecemos el tama‚àö¬±o inicial de la ventana"  	self crearFondo. 	self dibujarTodo.  	self takeKeyboardFocus. 		jugador:= Jugador_Carrera new.	score:= 0.	self addMorph: jugador.      textoScore := TextMorph new.  "Crear el morph de texto"	textoScore contents: 'SCORE: 0'.    textoScore color: Color white. "Configurar el color del texto"   textoScore position: 70@80. "Posicionar el texto en el mundo"   "Ajustar el tama‚àö¬±o del cuadro de texto (extent)"   textoScore extent: 100@50. "Ajustar manualmente el tama‚àö¬±o del morph"	self addMorph: textoScore.			self iniciar.! !!Juego_Carreras methodsFor: 'event handler' stamp: 'AlejandroTorres 11/12/2024 23:28'!handlesKeyboard    ^ true! !!Juego_Carreras methodsFor: 'event handler' stamp: 'AlejandroTorres 11/18/2024 02:21'!handleKeystroke: anEvent"Transcript show: 'Tecla presionada: ', anEvent keyValue printString; cr."|velocidad_jugador velocidad_jugador_negativa| "Se va moviendo respecto a la velocidad del jugador"velocidad_jugador:= jugador velocidad. velocidad_jugador_negativa:= (-1 * jugador velocidad). (corriendo)ifTrue:[   anEvent keyValue caseOf: {        [28] -> [jugador moverEnemigo: (velocidad_jugador_negativa  @ 0) and: 'izq'].  "Izquierda"        [30] -> [jugador moverEnemigo: (0 @ velocidad_jugador_negativa ) and: 'arriba']. "Arriba"        [29] -> [jugador moverEnemigo: (velocidad_jugador  @ 0) and: 'der'].   "Derecha"        [31] -> [						(jugador position y >= 580)ifFalse:[  "Para que no se salga del mapa".						jugador moverEnemigo: (0 @ velocidad_jugador ) and: 'abajo'.].]   "Abajo"} otherwise: [].]! !!Juego_Carreras methodsFor: 'enumerating' stamp: 'Tomy 11/21/2024 03:43'!whenGameEndsDo: aBlock    gameEndCallback := aBlock.! !!Juego_Carreras methodsFor: 'drawing' stamp: 'Tomy 11/21/2024 09:48'!dibujarScore	textoScore contents: 'SCORE: ', score asString. ! !!Juego_Carreras methodsFor: 'drawing' stamp: 'Tomy 11/21/2024 09:48'!dibujarTodo|enemigo|enemigo:= Enemigo_Carrera new. self addMorph: enemigo.	corriendo:= true. [  	[corriendo] whileTrue:[		self dibujarEnemigo: enemigo.				self dibujarScore. 		(Delay forSeconds: 0.1) wait.	].	(corriendo) ifFalse:[		self terminarJuego.	]] fork.	! !!Juego_Carreras methodsFor: 'drawing' stamp: 'Tomy 11/21/2024 09:48'!dibujarEnemigo: enemigo |newPosition randomNum x_inicial_random velocidad_jugador|velocidad_jugador:= jugador velocidad. randomNum := Random new.x_inicial_random := randomNum nextInt: 130 to: 380. "Se ajusta el rango de la nueva posici‚àö‚â•n para que aparezca dentro de la carretera"                 newPosition := enemigo position + (0 @ (enemigo velocidad)). "Mover hacia abajo (incrementar Y)"                                "Si el enemigo ha salido de la pantalla (supera la altura), lo reposicionamos arriba"                ((enemigo bounds bottom)  >= (self bounds bottom)) ifTrue: [  "Reaparecer en la parte superior en la misma posici‚àö‚â•n X"						  score:= score + 1. 						  jugador score: score.                      newPosition := (x_inicial_random @ 0).						  enemigo velocidad: (enemigo velocidad + 2.5). "Aumenta la velocidad del jugador y del enemigo en 2.5 pixeles por cada enemigo que sale de la pantalla, que equivale a 1 de score"						  jugador velocidad: velocidad_jugador + 2.5.                ].                                enemigo position: newPosition.  "Actualizamos la posici‚àö‚â•n del marker"           						corriendo:= (enemigo detectarColision: jugador) value. 	! !!Juego_Carreras methodsFor: 'as yet unclassified' stamp: 'Tomy 11/21/2024 09:47'!terminarJuego    gameOver ifTrue: [^self].  "Evita ejecuci√≥n repetida"    gameOver := true.  "Marca el juego como terminado"	    gameEndCallback ifNotNil: [gameEndCallback value].    "Mostrar el puntaje una sola vez"    UIManager default inform: 'Your score is: ', score asString.    	self owner ifNotNil: [        self owner takeKeyboardFocus.        Transcript show: 'Focus restaurado en el tablero'; cr.    ].    self delete.! !!Juego_Carreras methodsFor: 'as yet unclassified' stamp: 'Tomy 11/21/2024 03:46'!iniciar    "Inicializar el estado del juego"    gameOver := false.  "Bandera para controlar el estado del juego"   	 self takeKeyboardFocus.        "Ciclo principal del juego"    [        [				 self takeKeyboardFocus.				self verificarPuntaje.            (Delay forMilliseconds: 40) wait.        ] repeat    ] fork.! !!Juego_Carreras methodsFor: 'as yet unclassified' stamp: 'Tomy 11/21/2024 09:47'!verificarPuntaje    (score = 12 and: gameOver not) ifTrue: [        self terminarJuego.    ].! !!Juego_Carreras methodsFor: 'as yet unclassified' stamp: 'Tomy 11/21/2024 09:48'!exitGame	self delete.! !!Juego_Carreras methodsFor: 'accessing' stamp: 'AlejandroTorres 11/18/2024 02:14'!jugador	^ jugador! !!Juego_Carreras methodsFor: 'accessing' stamp: 'Tomy 11/21/2024 03:43'!gameOver^gameOver! !!Juego_Carreras methodsFor: 'accessing' stamp: 'Tomy 11/21/2024 09:48'!puntaje^score! !!Juego_Carreras methodsFor: 'accessing' stamp: 'AlejandroTorres 11/18/2024 02:14'!jugador: anObject	jugador := anObject! !Enemigo_Carrera subclass: #Jugador_Carrera	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Juego_Carreras'!!Jugador_Carrera methodsFor: 'initialization' stamp: 'Tomy 11/21/2024 09:48'!initialize |coordenadas_inicio|coordenadas_inicio:= 280@490.super initialize.self position: coordenadas_inicio. self image: (Form fromFileNamed: 'Jugador-100@100.png'). ! !!Jugador_Carrera methodsFor: 'as yet unclassified' stamp: 'Tomy 11/21/2024 09:48'!score: anObject	score := anObject! !!Jugador_Carrera methodsFor: 'as yet unclassified' stamp: 'Tomy 11/21/2024 09:48'!score	^ score! !Object subclass: #Random	instanceVariableNames: 'seed a m q r'	classVariableNames: ''	poolDictionaries: ''	category: 'Juego_Carreras'!!Random commentStamp: '' prior: 0!This Random Number Generator graciously contributed by David N. Smith.  It is an adaptation of the Park-Miller RNG [1] which uses Floats to avoid the need for LargeInteger arithmetic.If you just want a quick random integer, use:		10 atRandomEvery integer interval can give a random number:		(6 to: 12) atRandomSequenceableCollections can give randomly selected elements:		'pick one of these letters randomly' atRandomSequenceableCollections also respond to shuffled, as in:		($A to: $Z) shuffledThe correct way to use class Random is to store one in an instance or class variable:		myGenerator := Random new.Then use it every time you need another number between 0.0 and 1.0 (excluding)		myGenerator nextYou can also generate a positive integer		myGenerator nextInt: 10		[1] 'Random Number Generators:  Good Ones Are Hard to Find' by Stephen K. Park and Keith W. Miller (Comm. Asso. Comp. Mach., 31(10):1192--1201, 1988). http://www.firstpr.com.au/dsp/rand31/p1192-park.pdf!!Random methodsFor: 'initialization'!useUnixRandomGeneratorSeed	"Try to seed the receiver using random bytes from a Unix OS' /dev/random.	Return true if we succeeded, false otherwise.	Note that this might block until the OS thinks it has enough entropy."	^ [ (File named: '/dev/random') readStreamDo: [ :in | 			[ seed := (in next: 4) asInteger.			seed isZero ] whileTrue. "Try again if we ever get a zero value"			true ] ]		on: Error		do: [ false ]! !!Random methodsFor: 'initialization'!seed: aNumber	"Refer #privateNextSeed and [1], seed should be positive"	| newSeed |	newSeed := aNumber.	[ newSeed > 0 ] whileFalse: 		[ newSeed := newSeed + m ].	seed := newSeed.! !!Random methodsFor: 'initialization'!initialize	self useClockBasedSeed.	a := 16r000041A7 asFloat.    " magic constant =      16807 = 7^5"	m := 16r7FFFFFFF asFloat.    " magic constant = 2147483647 = 2^31 - 1"	q := (m quo: a) asFloat.	r  := (m \\ a) asFloat.! !!Random methodsFor: 'initialization'!useClockBasedSeed	"Set a reasonable Park-Miller starting seed [1] based on the ms clock."	[ seed := (Time millisecondClockValue bitAnd: 16r3FFFFFFF) bitXor: self hash.	seed = 0 ] whileTrue: [ "Try again if ever get a seed = 0" ]! !!Random methodsFor: 'private'!privateNextSeed	"This method generates random instances of Integer 	in the interval	0 to 16r7FFFFFFF. This method does NOT update the seed; repeated sends	answer the same value. The algorithm is described in detail in [1]"	| lo hi aLoRHi |	hi := (seed quo: q) asFloat.	lo := seed - (hi * q).  " = seed rem: q"  	aLoRHi := (a * lo) - (r * hi).	^(aLoRHi > 0.0)		ifTrue:  [aLoRHi]		ifFalse: [aLoRHi + m].! !!Random methodsFor: 'private'!seed	"Since [1] says... 	    'After initialization the ideal solution is to hide seed from the user'	...this method is placed in the 'private' protocol. Perhaps it sould even be deleted."	^ seed! !!Random methodsFor: 'private'!privateNextValue	"Answer a random Float in the interval [0 to 1)."	^ (seed := self privateNextSeed) / m! !!Random methodsFor: 'accessing'!next: anInteger	^ self next: anInteger into: (Array new: anInteger)! !!Random methodsFor: 'accessing'!nextInt: anInteger	"Answer a random integer in the interval [1, anInteger].	Handle large numbers too (for cryptography)."	anInteger strictlyPositive ifFalse: [ self error: 'Range must be positive' ].	anInteger asFloat isInfinite "are we outside the range of float? - use fraction"		ifTrue: [^(self privateNextValue asFraction * anInteger) truncated + 1].	^ (self privateNextValue * anInteger) truncated + 1! !!Random methodsFor: 'accessing'!next	"Answer a random Float in the interval [0 to 1)."	^ self privateNextValue! !!Random methodsFor: 'accessing'!next: anInteger into: anArray	1 to: anInteger do: [:index | anArray at: index put: self privateNextValue].	^ anArray! !!Random methodsFor: 'random' stamp: 'AlejandroTorres 11/16/2024 16:51'!nextInt: min to: max         | randomNumber range |        range := max - min + 1.  "El rango de n‚àö‚à´meros posibles"        randomNumber := (Random new nextInt: range) + min.  "Genera el n‚àö‚à´mero aleatorio y lo ajusta"        ^randomNumber.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Random class	instanceVariableNames: ''!!Random class methodsFor: 'testing'!bucketTest: randy	"Execute this:   Random bucketTest: Random new"	" A quick-and-dirty bucket test. Prints nbuckets values on theTranscript.	  Each should be 'near' the value of ntries. Any run with any value'far' from ntries	  indicates something is very wrong. Each run generates differentvalues.	  For a slightly better test, try values of nbuckets of 200-1000 ormore; go get coffee.	  This is a poor test; see Knuth.   Some 'OK' runs:		1000 1023 998 969 997 1018 1030 1019 1054 985 1003		1011 987 982 980 982 974 968 1044 976		1029 1011 1025 1016 997 1019 991 954 968 999 991		978 1035 995 988 1038 1009 988 993 976"	<script: 'Random bucketTest: Random new'>	| nbuckets buckets ntrys |	nbuckets := 20.	buckets := Array new: nbuckets.	buckets atAllPut: 0.	ntrys := 100.	ntrys * nbuckets		timesRepeat: [ | slot |			slot := (randy next * nbuckets) floor + 1.			buckets at: slot put: (buckets at: slot) + 1 ].	self		trace:			(String				streamContents: [ :stream | 					stream cr.					1 to: nbuckets do: [ :nb | 						(buckets at: nb) printOn: stream.						stream space ] ])! !!Random class methodsFor: 'instance creation'!seed: anInteger 	^self new seed: anInteger! !