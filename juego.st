Morph subclass: #MainMenu	instanceVariableNames: 'background'	classVariableNames: ''	poolDictionaries: ''	category: 'juego'!!MainMenu methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 02:13'!createBackground    "Cargar y mostrar la imagen de fondo"    background:= ImageMorph new.    background image: (Form fromFileNamed: 'MainMenuWT.png').     background extent: 640 @ 640.	background bounds: (0 @ 0 corner: 640 @ 640).    self extent: 640 @ 640.  "Ajusta el tamaño del menú"    self addMorph: background.! !!MainMenu methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 02:04'!playGame    "Mostrar el tablero y cerrar el menú"    Tablero new openInWorld.    self delete.  "Cierra el menú del juego"! !!MainMenu methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 02:25'!createButtons    | playButton exitButton |        "Botón Jugar"    playButton := SimpleButtonMorph new.    playButton label: 'Jugar'.	playButton color: Color black.		playButton extent: 100 @ 50.    playButton position: 270 @ 250.    playButton on: #mouseUp send: #playGame to: self.    self addMorph: playButton.    "Botón Salir"    exitButton := SimpleButtonMorph new.    exitButton label: 'Salir'.	exitButton color: Color black.	exitButton extent: 100 @ 50.    exitButton position: 270 @ 320.    exitButton on: #mouseUp send: #exitGame to: self.    self addMorph: exitButton.! !!MainMenu methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 02:04'!exitGame    "Cerrar el menú del juego"    self delete.! !!MainMenu methodsFor: 'initialization' stamp: 'TomasRodriguez 11/8/2024 02:02'!initialize    super initialize.    self extent: 400 @ 400.  "Tamaño del menú"    self createBackground.    self createButtons.! !Object subclass: #Pregunta	instanceVariableNames: 'pregunta opciones respuesta'	classVariableNames: ''	poolDictionaries: ''	category: 'juego'!!Pregunta methodsFor: 'accessing' stamp: 'TomasRodriguez 11/3/2024 19:11'!respuesta ^respuesta! !!Pregunta methodsFor: 'accessing' stamp: 'TomasRodriguez 11/3/2024 19:10'!pregunta^pregunta! !!Pregunta methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/3/2024 19:10'!opcion^opciones ! !!Pregunta methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/3/2024 19:11'!revisarRespuesta: anAnswer^ respuesta = anAnswer! !!Pregunta methodsFor: 'initialization' stamp: 'TomasRodriguez 11/3/2024 19:10'!initialize: aQuestion opciones: anOption respuesta: anAnswer     pregunta := aQuestion.    opciones:= anOption.    respuesta := anAnswer.! !Object subclass: #Quiz	instanceVariableNames: 'preguntas intentos puntaje'	classVariableNames: ''	poolDictionaries: ''	category: 'juego'!!Quiz methodsFor: 'adding' stamp: 'TomasRodriguez 11/3/2024 20:59'!addQuestion: aQuestion     preguntas add: aQuestion.! !!Quiz methodsFor: 'initialization' stamp: 'TomasRodriguez 11/3/2024 19:12'!initialize     preguntas := OrderedCollection new.    puntaje := 0.	intentos := 2.! !!Quiz methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/3/2024 21:30'!crearPreguntas|q1 q2|q1 := Pregunta new initialize: '¿Por morder qué fruta no se le permitió a Perséfone abandonar el Hades?' opciones: #('A. Una manzana' 'B. Un pomelo' 'C. Una Granada' 'D. Un arándano') respuesta: 'C'.q2 := Pregunta new initialize: '¿Quién ejerció como juez en la disputa entre Hera, Atenea y Afrodita?' opciones: #('A. Héctor' 'B. Agamenón' 'C. Paris' 'D. Aquiles') respuesta: 'C'.self addQuestion: q1.self addQuestion: q2.! !!Quiz methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/3/2024 21:29'!iniciar self crearPreguntas.preguntas do: [:pregunta |	 | response optionsStr |	optionsStr := (pregunta opcion collect: [:each | each asString]) asString.	response := UIManager default request: pregunta pregunta, ' (Options: ', optionsStr, ')'.        (pregunta revisarRespuesta: response)            ifTrue: [puntaje := puntaje + 1]            ifFalse: [UIManager default inform: 'Incorrect!!'].    ].    UIManager default inform: 'Your score is: ', puntaje asString.							  ! !Morph subclass: #Tablero	instanceVariableNames: 'playerPosition selectedEnemyPosition enemies'	classVariableNames: ''	poolDictionaries: ''	category: 'juego'!!Tablero methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/10/2024 19:11'!colorEnemy: position to: color2    | cellSize enemyMorph |    cellSize := self width // 4.  "Tamaño de cada celda en el tablero (4x4)"        "Busca el enemigo en la posición dada"    enemyMorph := self submorphs detect: [:morph |        ((morph bounds origin x // cellSize) @ (morph bounds origin y // cellSize)) = position    ] ifNone: [nil].        enemyMorph ifNotNil: [enemyMorph color: color2].! !!Tablero methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/10/2024 19:27'!adjacentPositionsTo: position    "Devuelve una colección de posiciones adyacentes válidas en el tablero."    ^ {(position + (1 @ 0)). "Derecha"       (position + (-1 @ 0)). "Izquierda"       (position + (0 @ 1)). "Abajo"       (position + (0 @ -1))} "Arriba"    select: [:pos |         (pos x between: 0 and: 3) and: (pos y between: 0 and: 3)].! !!Tablero methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 01:35'!createSquares    | squareSize squareColor square creamColor |    squareSize := self width // 4.  "Debería ser 100 si width es 400"        "Definir el color crema"    creamColor := Color r: 1.0 g: 0.95 b: 0.8.        0 to: 3 do: [ :row |        0 to: 3 do: [ :col |            "Determinar color en base a la paridad de la fila y columna"            squareColor := ((row + col) even) ifTrue: [Color veryLightGray] ifFalse: [creamColor].                        "Crear y configurar cada cuadrado"            square := Morph new.            square color: squareColor.                        "Establecer los límites de cada cuadrado"            square bounds: ((col * squareSize) @ (row * squareSize) extent: (squareSize @ squareSize)).                        "Agregar cuadrado al tablero"            self addMorph: square        ]    ].! !!Tablero methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/10/2024 20:04'!moveSelection: direction    | newSelectedPosition |    newSelectedPosition := selectedEnemyPosition + direction.    Transcript show: 'Intentando mover a: ', newSelectedPosition printString; cr.    (((newSelectedPosition x between: 0 and: 3) and: (newSelectedPosition y between: 0 and: 3))         and: (enemies includes: newSelectedPosition)) ifTrue: [                "Restaurar color del enemigo previo"        Transcript show: 'Restaurando color en posición: ', selectedEnemyPosition printString; cr.        self colorEnemy: selectedEnemyPosition to: Color red.                newSelectedPosition = playerPosition ifFalse: [          selectedEnemyPosition := newSelectedPosition.        Transcript show: 'Nuevo enemigo seleccionado en: ', selectedEnemyPosition printString; cr.        self colorEnemy: selectedEnemyPosition to: Color green.			].    ].! !!Tablero methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 04:26'!handlesKeyboard    ^ true! !!Tablero methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/10/2024 19:19'!adjacentEnemy    "Devuelve la primera posición de enemigo que está adyacente a playerPosition, o nil si no hay enemigos adyacentes."    | adjacentEnemies |    adjacentEnemies := self adjacentPositionsTo: playerPosition.    ^ adjacentEnemies detect: [:pos | enemies includes: pos] ifNone: [nil].! !!Tablero methodsFor: 'event handling' stamp: 'TomasRodriguez 11/10/2024 20:00'!handleKeystroke: anEvent    Transcript show: 'Tecla presionada: ', anEvent keyValue printString; cr.    anEvent keyValue caseOf: {        [28] -> [self moveSelection: (-1 @ 0)].  "Izquierda"        [30] -> [self moveSelection: (0 @ -1)].  "Arriba"        [29] -> [self moveSelection: (1 @ 0)].   "Derecha"        [31] -> [self moveSelection: (0 @ 1)].   "Abajo"        [13] -> [            (enemies includes: selectedEnemyPosition) ifTrue: [					| quiz |                quiz := Quiz new.                quiz iniciar.            ].        ]  "Enter para iniciar Quiz si hay un enemigo seleccionado"    } otherwise: [].! !!Tablero methodsFor: 'adding' stamp: 'TomasRodriguez 11/8/2024 01:53'!addPlayerAndEnemies    | squareSize enemyColor playerColor circlePosition circle |    squareSize := self width // 4.    enemyColor := Color red.    playerColor := Color blue.    0 to: 3 do: [ :row |        0 to: 3 do: [ :col |            "Determina la posición del círculo en la casilla actual"            circlePosition := ((col * squareSize) @ (row * squareSize)) + ((squareSize // 2) @ (squareSize // 2)).								circle:= EllipseMorph new.            circle color: ((row @ col = playerPosition) ifTrue: [playerColor] ifFalse: [enemyColor]).            circle bounds: (circlePosition - ((squareSize // 4) @ (squareSize // 4)) corner: circlePosition + ((squareSize // 4) @ (squareSize // 4))).            "Agregar el círculo al tablero"            self addMorph: circle.        ].    ].! !!Tablero methodsFor: 'initialization' stamp: 'TomasRodriguez 11/8/2024 04:25'!initializeEnemies    | allPositions |    allPositions := (0 to: 3) flatCollect: [:row |         (0 to: 3) collect: [:col | row @ col]    ].    ^allPositions reject: [:pos | pos = playerPosition].  "Excluir la posición del jugador"! !!Tablero methodsFor: 'initialization' stamp: 'TomasRodriguez 11/10/2024 19:47'!initialize|cream|cream:= Color r: 1.0 g: 0.95 b: 0.8.    super initialize.    self color: cream.    self extent: 640@640.  "Set the size of the chessboard" 	 playerPosition := (0 to: 3) atRandom @ (0 to: 3) atRandom.		enemies := self initializeEnemies.	 selectedEnemyPosition := self adjacentEnemy.    selectedEnemyPosition ifNotNil: [self colorEnemy: selectedEnemyPosition to: Color green].    self createSquares.    self addPlayerAndEnemies.    self takeKeyboardFocus.! !