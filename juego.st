Morph subclass: #MainMenu	instanceVariableNames: 'background'	classVariableNames: ''	poolDictionaries: ''	category: 'juego'!!MainMenu methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 02:04'!exitGame    "Cerrar el men√∫ del juego"    self delete.! !!MainMenu methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 02:04'!playGame    "Mostrar el tablero y cerrar el men√∫"    Tablero new openInWorld.    self delete.  "Cierra el men√∫ del juego"! !!MainMenu methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 02:13'!createBackground    "Cargar y mostrar la imagen de fondo"    background:= ImageMorph new.    background image: (Form fromFileNamed: 'MainMenuWT.png').     background extent: 640 @ 640.	background bounds: (0 @ 0 corner: 640 @ 640).    self extent: 640 @ 640.  "Ajusta el tama√±o del men√∫"    self addMorph: background.! !!MainMenu methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 02:25'!createButtons    | playButton exitButton |        "Bot√≥n Jugar"    playButton := SimpleButtonMorph new.    playButton label: 'Jugar'.	playButton color: Color black.		playButton extent: 100 @ 50.    playButton position: 270 @ 250.    playButton on: #mouseUp send: #playGame to: self.    self addMorph: playButton.    "Bot√≥n Salir"    exitButton := SimpleButtonMorph new.    exitButton label: 'Salir'.	exitButton color: Color black.	exitButton extent: 100 @ 50.    exitButton position: 270 @ 320.    exitButton on: #mouseUp send: #exitGame to: self.    self addMorph: exitButton.! !!MainMenu methodsFor: 'initialization' stamp: 'TomasRodriguez 11/8/2024 02:02'!initialize    super initialize.    self extent: 400 @ 400.  "Tama√±o del men√∫"    self createBackground.    self createButtons.! !Object subclass: #Pregunta	instanceVariableNames: 'pregunta opciones respuesta'	classVariableNames: ''	poolDictionaries: ''	category: 'juego'!!Pregunta methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/3/2024 19:10'!opcion^opciones ! !!Pregunta methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/3/2024 19:11'!revisarRespuesta: anAnswer^ respuesta = anAnswer! !!Pregunta methodsFor: 'accessing' stamp: 'TomasRodriguez 11/3/2024 19:11'!respuesta ^respuesta! !!Pregunta methodsFor: 'accessing' stamp: 'TomasRodriguez 11/3/2024 19:10'!pregunta^pregunta! !!Pregunta methodsFor: 'initialization' stamp: 'TomasRodriguez 11/3/2024 19:10'!initialize: aQuestion opciones: anOption respuesta: anAnswer     pregunta := aQuestion.    opciones:= anOption.    respuesta := anAnswer.! !Object subclass: #Quiz	instanceVariableNames: 'preguntas intentos puntaje'	classVariableNames: ''	poolDictionaries: ''	category: 'juego'!!Quiz methodsFor: 'initialization' stamp: 'Tomas 11/16/2024 00:48'!initialize     preguntas := OrderedCollection new.    puntaje := 0.! !!Quiz methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/3/2024 21:30'!crearPreguntas|q1 q2|q1 := Pregunta new initialize: '¬øPor morder qu√© fruta no se le permiti√≥ a Pers√©fone abandonar el Hades?' opciones: #('A. Una manzana' 'B. Un pomelo' 'C. Una Granada' 'D. Un ar√°ndano') respuesta: 'C'.q2 := Pregunta new initialize: '¬øQui√©n ejerci√≥ como juez en la disputa entre Hera, Atenea y Afrodita?' opciones: #('A. H√©ctor' 'B. Agamen√≥n' 'C. Paris' 'D. Aquiles') respuesta: 'C'.self addQuestion: q1.self addQuestion: q2.! !!Quiz methodsFor: 'as yet unclassified' stamp: 'Tomas 11/15/2024 07:28'!iniciar self crearPreguntas.preguntas do: [:pregunta |	 | response optionsStr |	optionsStr := (pregunta opcion collect: [:each | each asString]) asString.	response := UIManager default request: pregunta pregunta, ' (Options: ', optionsStr, ')'.        (pregunta revisarRespuesta: response)            ifTrue: [puntaje := puntaje + 6]            ifFalse: [UIManager default inform: 'Incorrect!!'].    ].    UIManager default inform: 'Your score is: ', puntaje asString.							  ! !!Quiz methodsFor: 'adding' stamp: 'TomasRodriguez 11/3/2024 20:59'!addQuestion: aQuestion     preguntas add: aQuestion.! !!Quiz methodsFor: 'accessing' stamp: 'Tomas 11/15/2024 00:18'!puntaje^puntaje! !Morph subclass: #Tablero	instanceVariableNames: 'playerPosition selectedEnemyPosition enemies capturedEnemies'	classVariableNames: ''	poolDictionaries: ''	category: 'juego'!!Tablero methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 01:35'!createSquares    | squareSize squareColor square creamColor |    squareSize := self width // 4.  "Deber√≠a ser 100 si width es 400"        "Definir el color crema"    creamColor := Color r: 1.0 g: 0.95 b: 0.8.        0 to: 3 do: [ :row |        0 to: 3 do: [ :col |            "Determinar color en base a la paridad de la fila y columna"            squareColor := ((row + col) even) ifTrue: [Color veryLightGray] ifFalse: [creamColor].                        "Crear y configurar cada cuadrado"            square := Morph new.            square color: squareColor.                        "Establecer los l√≠mites de cada cuadrado"            square bounds: ((col * squareSize) @ (row * squareSize) extent: (squareSize @ squareSize)).                        "Agregar cuadrado al tablero"            self addMorph: square        ]    ].! !!Tablero methodsFor: 'as yet unclassified' stamp: 'Tomas 11/16/2024 21:27'!startRandomGame    | randomChoice quiz space |    randomChoice := #(#Quiz #SpaceInvaders) atRandom.    randomChoice caseOf: {        [#Quiz] -> [            quiz := Quiz new.            quiz iniciar.            self endGameWithScore: quiz puntaje.            self takeKeyboardFocus.  "Restablecer foco al tablero después del quiz"        ].        [#SpaceInvaders] -> [            space := SpaceInvaders new.            space iniciarSI.  "Inicia el juego de Space Invaders"            space takeKeyboardFocus.  "Dar foco a Space Invaders"				space whenGameEndsDo: [                Transcript show: 'Puntaje final de Space Invaders: ', space puntaje asString; cr.                self endGameWithScore: space puntaje.                self takeKeyboardFocus.  "Restablecer foco al tablero"            ].            self endGameWithScore: space puntaje.          self takeKeyboardFocus.  "Restablecer foco al tablero"        ].    } otherwise: [].! !!Tablero methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 04:26'!handlesKeyboard    ^ true! !!Tablero methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/10/2024 19:19'!adjacentEnemy    "Devuelve la primera posici√≥n de enemigo que est√° adyacente a playerPosition, o nil si no hay enemigos adyacentes."    | adjacentEnemies |    adjacentEnemies := self adjacentPositionsTo: playerPosition.    ^ adjacentEnemies detect: [:pos | enemies includes: pos] ifNone: [nil].! !!Tablero methodsFor: 'as yet unclassified' stamp: 'Tomas 11/16/2024 21:06'!endGameWithScore: score    | adjacentEnemies notCaptured |Transcript show: 'Hola estoy calculando el puntaje';cr.    "Si el puntaje es suficiente, cambiar el color del enemigo seleccionado a azul"    (score >= 12) ifTrue: [        Transcript show: 'Coloreando enemigo en posición: ', selectedEnemyPosition printString; cr.        "Colorear el enemigo seleccionado y agregarlo a capturados"        self colorEnemy: selectedEnemyPosition to: Color blue.        capturedEnemies add: selectedEnemyPosition.        "Obtener posiciones adyacentes y filtrar enemigos no capturados"        adjacentEnemies := self adjacentPositionsTo: selectedEnemyPosition.        notCaptured := adjacentEnemies select: [:pos |             (enemies includes: pos) and: (capturedEnemies includes: pos) not        ].        "Seleccionar el primer enemigo no capturado y cambiar su color a verde"        notCaptured isEmpty ifFalse: [            selectedEnemyPosition := notCaptured first.            Transcript show: 'Nuevo enemigo seleccionado en posición: ', selectedEnemyPosition printString; cr.            self colorEnemy: selectedEnemyPosition to: Color green.        ].        "Recuperar el foco al tablero"        self takeKeyboardFocus.        Transcript show: 'Foco restablecido en el tablero'; cr.    ].! !!Tablero methodsFor: 'as yet unclassified' stamp: 'Tomas 11/15/2024 00:30'!moveSelection: direction    | newSelectedPosition |    newSelectedPosition := selectedEnemyPosition + direction.    Transcript show: 'Intentando mover a: ', newSelectedPosition printString; cr.    (((newSelectedPosition x between: 0 and: 3) and: (newSelectedPosition y between: 0 and: 3))         and: (enemies includes: newSelectedPosition)) ifTrue: [                "Restaurar color del enemigo previo solo si no está capturado"        (capturedEnemies includes: selectedEnemyPosition) ifFalse: [            Transcript show: 'Restaurando color en posición: ', selectedEnemyPosition printString; cr.            self colorEnemy: selectedEnemyPosition to: Color red.        ].		 (capturedEnemies includes: selectedEnemyPosition) ifFalse: [        newSelectedPosition = playerPosition ifFalse: [              selectedEnemyPosition := newSelectedPosition.            Transcript show: 'Nuevo enemigo seleccionado en: ', selectedEnemyPosition printString; cr.            self colorEnemy: selectedEnemyPosition to: Color green.        ].].    ].! !!Tablero methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/10/2024 19:11'!colorEnemy: position to: color2    | cellSize enemyMorph |    cellSize := self width // 4.  "Tama√±o de cada celda en el tablero (4x4)"        "Busca el enemigo en la posici√≥n dada"    enemyMorph := self submorphs detect: [:morph |        ((morph bounds origin x // cellSize) @ (morph bounds origin y // cellSize)) = position    ] ifNone: [nil].        enemyMorph ifNotNil: [enemyMorph color: color2].! !!Tablero methodsFor: 'as yet unclassified' stamp: 'Tomas 11/16/2024 01:50'!selectNextEnemy    | availableEnemies |    availableEnemies := enemies copyWithoutAll: capturedEnemies.    availableEnemies isEmpty ifFalse: [        selectedEnemyPosition := availableEnemies first position.        self colorEnemy: selectedEnemyPosition to: Color green. "Colorear el nuevo enemigo seleccionado"    ].! !!Tablero methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/10/2024 19:27'!adjacentPositionsTo: position    "Devuelve una colecci√≥n de posiciones adyacentes v√°lidas en el tablero."    ^ {(position + (1 @ 0)). "Derecha"       (position + (-1 @ 0)). "Izquierda"       (position + (0 @ 1)). "Abajo"       (position + (0 @ -1))} "Arriba"    select: [:pos |         (pos x between: 0 and: 3) and: (pos y between: 0 and: 3)].! !!Tablero methodsFor: 'as yet unclassified' stamp: 'Tomas 11/16/2024 01:45'!terminateAllDelays    "Termina todos los procesos relacionados con Delay"    Process allInstances do: [:each |        each suspendedContext ifNotNil: [            | receiver |            receiver := each suspendedContext receiver.            (receiver notNil and: [                receiver isKindOf: Delay            ]) ifTrue: [                each terminate.                Transcript show: 'Proceso Delay eliminado'; cr.            ].        ].    ].! !!Tablero methodsFor: 'initialization' stamp: 'Tomas 11/15/2024 00:26'!initialize|cream|cream:= Color r: 1.0 g: 0.95 b: 0.8.    super initialize.    self color: cream.    self extent: 640@640.  "Set the size of the chessboard" 	 playerPosition := (0 to: 3) atRandom @ (0 to: 3) atRandom.		enemies := self initializeEnemies.		capturedEnemies:= OrderedCollection new.	 selectedEnemyPosition := self adjacentEnemy.    selectedEnemyPosition ifNotNil: [self colorEnemy: selectedEnemyPosition to: Color green].    self createSquares.    self addPlayerAndEnemies.    self takeKeyboardFocus.! !!Tablero methodsFor: 'initialization' stamp: 'TomasRodriguez 11/8/2024 04:25'!initializeEnemies    | allPositions |    allPositions := (0 to: 3) flatCollect: [:row |         (0 to: 3) collect: [:col | row @ col]    ].    ^allPositions reject: [:pos | pos = playerPosition].  "Excluir la posici√≥n del jugador"! !!Tablero methodsFor: 'event handling' stamp: 'Tomas 11/16/2024 21:02'!handleKeystroke: anEvent    Transcript show: 'Tecla presionada: ', anEvent keyValue printString; cr.    anEvent keyValue caseOf: {        [28] -> [self moveSelection: (-1 @ 0)].  "Izquierda"        [30] -> [self moveSelection: (0 @ -1)].  "Arriba"        [29] -> [self moveSelection: (1 @ 0)].   "Derecha"        [31] -> [self moveSelection: (0 @ 1)].   "Abajo"        [13] -> [            (enemies includes: selectedEnemyPosition) ifTrue: [                self startRandomGame.                "Recuperar el enfoque en el tablero después de ejecutar el juego"                self takeKeyboardFocus.            ].        ]  "Enter para iniciar el juego si hay un enemigo seleccionado"    } otherwise: [].! !!Tablero methodsFor: 'adding' stamp: 'TomasRodriguez 11/8/2024 01:53'!addPlayerAndEnemies    | squareSize enemyColor playerColor circlePosition circle |    squareSize := self width // 4.    enemyColor := Color red.    playerColor := Color blue.    0 to: 3 do: [ :row |        0 to: 3 do: [ :col |            "Determina la posici√≥n del c√≠rculo en la casilla actual"            circlePosition := ((col * squareSize) @ (row * squareSize)) + ((squareSize // 2) @ (squareSize // 2)).								circle:= EllipseMorph new.            circle color: ((row @ col = playerPosition) ifTrue: [playerColor] ifFalse: [enemyColor]).            circle bounds: (circlePosition - ((squareSize // 4) @ (squareSize // 4)) corner: circlePosition + ((squareSize // 4) @ (squareSize // 4))).            "Agregar el c√≠rculo al tablero"            self addMorph: circle.        ].    ].! !