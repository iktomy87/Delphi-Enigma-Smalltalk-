Morph subclass: #MainMenu	instanceVariableNames: 'background'	classVariableNames: ''	poolDictionaries: ''	category: 'juego'!!MainMenu methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 02:13'!createBackground    "Cargar y mostrar la imagen de fondo"    background:= ImageMorph new.    background image: (Form fromFileNamed: 'MainMenuWT.png').     background extent: 640 @ 640.	background bounds: (0 @ 0 corner: 640 @ 640).    self extent: 640 @ 640.  "Ajusta el tamaño del menú"    self addMorph: background.! !!MainMenu methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 02:04'!playGame    "Mostrar el tablero y cerrar el menú"    Tablero new openInWorld.    self delete.  "Cierra el menú del juego"! !!MainMenu methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 02:25'!createButtons    | playButton exitButton |        "Botón Jugar"    playButton := SimpleButtonMorph new.    playButton label: 'Jugar'.	playButton color: Color black.		playButton extent: 100 @ 50.    playButton position: 270 @ 250.    playButton on: #mouseUp send: #playGame to: self.    self addMorph: playButton.    "Botón Salir"    exitButton := SimpleButtonMorph new.    exitButton label: 'Salir'.	exitButton color: Color black.	exitButton extent: 100 @ 50.    exitButton position: 270 @ 320.    exitButton on: #mouseUp send: #exitGame to: self.    self addMorph: exitButton.! !!MainMenu methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 02:04'!exitGame    "Cerrar el menú del juego"    self delete.! !!MainMenu methodsFor: 'initialization' stamp: 'TomasRodriguez 11/8/2024 02:02'!initialize    super initialize.    self extent: 400 @ 400.  "Tamaño del menú"    self createBackground.    self createButtons.! !Object subclass: #Pregunta	instanceVariableNames: 'pregunta opciones respuesta'	classVariableNames: ''	poolDictionaries: ''	category: 'juego'!!Pregunta methodsFor: 'accessing' stamp: 'TomasRodriguez 11/3/2024 19:11'!respuesta ^respuesta! !!Pregunta methodsFor: 'accessing' stamp: 'TomasRodriguez 11/3/2024 19:10'!pregunta^pregunta! !!Pregunta methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/3/2024 19:10'!opcion^opciones ! !!Pregunta methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/3/2024 19:11'!revisarRespuesta: anAnswer^ respuesta = anAnswer! !!Pregunta methodsFor: 'initialization' stamp: 'TomasRodriguez 11/3/2024 19:10'!initialize: aQuestion opciones: anOption respuesta: anAnswer     pregunta := aQuestion.    opciones:= anOption.    respuesta := anAnswer.! !Object subclass: #Quiz	instanceVariableNames: 'preguntas intentos puntaje'	classVariableNames: ''	poolDictionaries: ''	category: 'juego'!!Quiz methodsFor: 'adding' stamp: 'TomasRodriguez 11/3/2024 20:59'!addQuestion: aQuestion     preguntas add: aQuestion.! !!Quiz methodsFor: 'initialization' stamp: 'TomasRodriguez 11/3/2024 19:12'!initialize     preguntas := OrderedCollection new.    puntaje := 0.	intentos := 2.! !!Quiz methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/3/2024 21:30'!crearPreguntas|q1 q2|q1 := Pregunta new initialize: '¿Por morder qué fruta no se le permitió a Perséfone abandonar el Hades?' opciones: #('A. Una manzana' 'B. Un pomelo' 'C. Una Granada' 'D. Un arándano') respuesta: 'C'.q2 := Pregunta new initialize: '¿Quién ejerció como juez en la disputa entre Hera, Atenea y Afrodita?' opciones: #('A. Héctor' 'B. Agamenón' 'C. Paris' 'D. Aquiles') respuesta: 'C'.self addQuestion: q1.self addQuestion: q2.! !!Quiz methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/3/2024 21:29'!iniciar self crearPreguntas.preguntas do: [:pregunta |	 | response optionsStr |	optionsStr := (pregunta opcion collect: [:each | each asString]) asString.	response := UIManager default request: pregunta pregunta, ' (Options: ', optionsStr, ')'.        (pregunta revisarRespuesta: response)            ifTrue: [puntaje := puntaje + 1]            ifFalse: [UIManager default inform: 'Incorrect!!'].    ].    UIManager default inform: 'Your score is: ', puntaje asString.							  ! !Morph subclass: #Tablero	instanceVariableNames: 'playerPosition selectedEnemyPosition enemies'	classVariableNames: ''	poolDictionaries: ''	category: 'juego'!!Tablero methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 02:35'!colorEnemy: position to: color2    | enemy |    enemy := self submorphs detect: [:morph | morph bounds origin = (position * (self width // 4))].    enemy color: color2.! !!Tablero methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 01:35'!createSquares    | squareSize squareColor square creamColor |    squareSize := self width // 4.  "Debería ser 100 si width es 400"        "Definir el color crema"    creamColor := Color r: 1.0 g: 0.95 b: 0.8.        0 to: 3 do: [ :row |        0 to: 3 do: [ :col |            "Determinar color en base a la paridad de la fila y columna"            squareColor := ((row + col) even) ifTrue: [Color veryLightGray] ifFalse: [creamColor].                        "Crear y configurar cada cuadrado"            square := Morph new.            square color: squareColor.                        "Establecer los límites de cada cuadrado"            square bounds: ((col * squareSize) @ (row * squareSize) extent: (squareSize @ squareSize)).                        "Agregar cuadrado al tablero"            self addMorph: square        ]    ].! !!Tablero methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 02:35'!moveSelection: direction    | newSelectedPosition |    newSelectedPosition := selectedEnemyPosition + direction.    (enemies includes: newSelectedPosition) ifTrue: [        "Restaurar color del enemigo previo"        self colorEnemy: selectedEnemyPosition to: Color red.                "Actualizar selección y colorear el nuevo enemigo"        selectedEnemyPosition := newSelectedPosition.        self colorEnemy: selectedEnemyPosition to: Color green.    ].! !!Tablero methodsFor: 'as yet unclassified' stamp: 'TomasRodriguez 11/8/2024 02:34'!adjacentEnemy    | directions adjacent |    directions := {1 @ 0. -1 @ 0. 0 @ 1. 0 @ -1}.  "Direcciones de vecinos adyacentes: derecha, izquierda, abajo, arriba"    adjacent := directions detect: [:direction |         | potentialPosition |        potentialPosition := playerPosition + direction.        enemies includes: potentialPosition    ] ifNone: [enemies anyOne].  "Si no hay enemigos adyacentes, selecciona cualquiera"        ^playerPosition + adjacent.! !!Tablero methodsFor: 'event handling' stamp: 'TomasRodriguez 11/8/2024 02:42'!handleKeystroke: anEvent    anEvent keyValue caseOf: {        [37] -> [self moveSelection: (-1 @ 0)].  "Izquierda"        [38] -> [self moveSelection: (0 @ -1)].  "Arriba"        [39] -> [self moveSelection: (1 @ 0)].   "Derecha"        [40] -> [self moveSelection: (0 @ 1)].   "Abajo"        [13] -> [|quiz|. quiz:= Quiz new iniciar].              "Enter para iniciar Quiz"    } otherwise: [].! !!Tablero methodsFor: 'adding' stamp: 'TomasRodriguez 11/8/2024 01:53'!addPlayerAndEnemies    | squareSize enemyColor playerColor circlePosition circle |    squareSize := self width // 4.    enemyColor := Color red.    playerColor := Color blue.    0 to: 3 do: [ :row |        0 to: 3 do: [ :col |            "Determina la posición del círculo en la casilla actual"            circlePosition := ((col * squareSize) @ (row * squareSize)) + ((squareSize // 2) @ (squareSize // 2)).								circle:= EllipseMorph new.            circle color: ((row @ col = playerPosition) ifTrue: [playerColor] ifFalse: [enemyColor]).            circle bounds: (circlePosition - ((squareSize // 4) @ (squareSize // 4)) corner: circlePosition + ((squareSize // 4) @ (squareSize // 4))).            "Agregar el círculo al tablero"            self addMorph: circle.        ].    ].! !!Tablero methodsFor: 'initialization' stamp: 'TomasRodriguez 11/8/2024 02:40'!initializeEnemies    | allPositions |    allPositions := (0 to: 3) flatCollect: [:row |         (0 to: 3) collect: [:col | row @ col]    ].    ^allPositions reject: [:pos | pos = playerPosition].  "Excluir la posición del jugador"! !!Tablero methodsFor: 'initialization' stamp: 'TomasRodriguez 11/8/2024 02:39'!initialize|cream|cream:= Color r: 1.0 g: 0.95 b: 0.8.    super initialize.    self color: cream.    self extent: 640@640.  "Set the size of the chessboard" 	 playerPosition := (0 to: 3) atRandom @ (0 to: 3) atRandom.		enemies := self initializeEnemies.    selectedEnemyPosition := self adjacentEnemy.  "Inicia con un enemigo adyacente seleccionado"    self createSquares.    self addPlayerAndEnemies.! !